:data-uri:
ifdef::env-build[:icons: font]


http://www.javaperformancetuning.com/tips/rawtips.shtml

* Computer architecture
 https://www.youtube.com/watch?v=OFgxAFdxYAQ
  http://www.azulsystems.com/events/javaone_2009/session/2009_J1_HardwareCrashCourse.pdf
** Von Neuman (abstraction, not real anymore)
** real architecture (multi-core, instructions pipelines, cache levels...)
** typical latencies
image:typical_latencies/pydata-paris-2015-closing-keynote-francesc-alted-16-638.jpg[]
 https://gist.github.com/hellerbarde/2843375

* performance improvement process (see JPT)
** no premature optimization
** have a performance objective
** concentrate of the 20% of the app that is responsible for 80% of the load
** one issue often hides other issues
** first actions might not show any improvement. Yet, don't despair!
** test in real-life conditions (DB size, # simultaneous users, server sizing...)
** OS contention, then GC issues, then code optimization
** ...

* Most frequent sources of performance issues

** memory, objects lifecycle
*** _See also JPT course_
*** useless allocation/deallocation: try to re-use objects -> consider using object pools
*** big objects in memory (e.g. file transfer -> use streaming)
*** chase memory leaks
*** use SoftReference for long-lived objects
*** difficult: balance memory used vs. performance
**** E.g.: reduce session scope as much as possible => more DB requests!
*** prefer local variables over class variables
*** don't +System.gc()+
*** prefer StringBuilder over '+' or String.format
*** allocate collections/buffers/builders with appropriate initialCapacity
*** avoid allocating objects in loops

** remote services
*** -> use caches for slow services
*** set your timeouts!
*** use async services if you can
*** use connections/clients pool
*** consider using a circuit breaker
 https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern

** disk I/Os
*** *all* logging frameworks are bad performance-wise -> reduce logging to a strict minimum when in PROD
*** prefer async logging framework
**** NOTE: "security logging" is *not* logging (should be called "security audit trace")
*** generally speaking, avoid writing to disk

** architecture
*** prefer many small servers to few big servers

* Less frequent sources of performance issues

** CPU
*** don't use exceptions as return values / for control flow!
*** choose your collections implementations carefully
 http://java-performance.info/java-collections-overview/ :
+
[cols="h,a,a"]
|=====
| {nbsp} | Single threaded | Concurrent
| Lists	|
* +ArrayList+ – generic array-based
* +LinkedList+ – do not use
* +Vector+ – deprecated
|
* +CopyOnWriteArrayList+ – seldom updated, often traversed
| Queues / deques |
* +ArrayDeque+ – generic array-based
* +Stack+ – deprecated
* +PriorityQueue+ – sorted retrieval operations
|
* +ArrayBlockingQueue+ – bounded blocking queue
* +ConcurrentLinkedDeque+ / ConcurrentLinkedQueue – unbounded linked queue (CAS)
* +DelayQueue+ – queue with delays on each element
* +LinkedBlockingDeque+ / LinkedBlockingQueue – optionally bounded linked queue (locks)
* +LinkedTransferQueue+ – may transfer elements w/o storing
* +PriorityBlockingQueue+ – concurrent PriorityQueue
* +SynchronousQueue+ – Exchanger with Queue interface
| Maps |
* +HashMap+ – generic map
* +EnumMap+ – enum keys
* +Hashtable+ – deprecated
* +IdentityHashMap+ – keys compared with ==
* +LinkedHashMap+ – keeps insertion order
* +TreeMap+ – sorted keys
* +WeakHashMap+ – useful for caches
|
* +ConcurrentHashMap+ – generic concurrent map
* +ConcurrentSkipListMap+ – sorted concurrent map
| Set |
* +HashSet+ – generic set
* +EnumSet+ – set of enums
* +BitSet+ – set of bits/dense integers
* +LinkedHashSet+ – keeps insertion order
* +TreeSet+ – sorted set
|
* +ConcurrentSkipListSet+ – sorted concurrent set
* +CopyOnWriteArraySet+ – seldom updated, often traversed
|=====
*** choose your algorithms carefully (e.g. sort...)
*** use market proof algorithms implementations
*** know how your CPU work (e.g. cache levels)
*** favor inlining by the JIT (...)
*** replace Lists and Strings by arrays
*** cryptography is slow
*** XML parsing is slow
*** serializing/deserializing is slow
*** creating a regexp is slow
*** prefer StringBuilder over String.format
*** avoid polling
*** getters/setters may hurt (if not inlined)

* Out-of-scope
** java fat clients performance (AWT, Swing, JavaFX...)
